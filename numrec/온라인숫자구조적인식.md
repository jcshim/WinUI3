이미 CNN+ONNX는 성공하셨으니까, 이제 “온라인 필기 정보(스트로크)”를 최대한 활용해서 **구조적으로** 해석하는 큰 틀만 정리해 볼게요 👍

---

## 1. 전체 흐름 구조

온라인 숫자 인식을 “구조적으로” 한다는 건, 결국:

1. **스트로크 데이터 수집**

   * 각 스트로크마다:

     * 시작점 (x₀, y₀)
     * 끝점 (xₙ, yₙ)
     * 포인트 시퀀스 {p₀, p₁, …, pₙ}
   * 스트로크 순서(1획, 2획, 3획…)과 방향(위→아래/왼→오른쪽 등)

2. **정규화**

   * 전체 포인트의 바운딩 박스(BBox) 계산 → (minX, minY) ~ (maxX, maxY)
   * BBox를 기준으로

     * 크기 정규화(가로·세로를 일정 범위로 스케일)
     * 위치 정규화(중심을 (0,0) 근처로 옮김)

3. **특징(feature) 추출**

   * “온라인 특징”: 스트로크를 그대로 이용한 특징
   * “오프라인 특징”: 격자로 rasterize해서 이미지처럼 보는 특징

4. **규칙/분류기**

   * 각 숫자(0~9)에 대한 전형적인 패턴을 규칙으로 만든 뒤,
   * feature vector와 비교해서 가장 잘 맞는 숫자를 선택.

---

## 2. 온라인 특징 – 스트로크 기반

온라인 필기니까, 여기서 얻을 수 있는 중요한 정보들입니다.

1. **스트로크 개수**

   * 예시 경향:

     * 0: 보통 1획
     * 1: 1획 또는 2획(밑에 꼬리 추가)
     * 4: 2~3획
     * 7: 1획
     * 8: 1~2획
   * “필기 스타일”에 따라 달라질 수 있으므로, **강한 규칙**보다는 **참고 정보**로 사용.

2. **시작점/끝점 위치 (정규화 좌표로)**

   * 예:

     * 1: 위쪽에서 시작해 아래로 곧게 내려오는 패턴이 많음.
     * 7: 왼쪽 위에서 오른쪽으로 선을 긋고 → 오른쪽 위나 중간에서 내려오는 패턴.
     * 9: 중앙~위쪽에서 시작해 원을 그리다가 위쪽에서 끝나는 패턴.
   * “시작/끝 위치 + 전체 경로 방향”을 함께 보면 방향성이 살아납니다.

3. **전체 방향·길이 벡터**

   * 각 스트로크에 대해 (끝점 - 시작점) 벡터를 계산:

     * (dx, dy), 길이, 기울기(atan2).
   * 예:

     * 세로로 길쭉( |dy| ≫ |dx| ) → 1, 4의 일부 획
     * 가로로 길쭉( |dx| ≫ |dy| ) → 7의 윗획, 2의 상단, 5의 상단 등

4. **획 순서 패턴**

   * 예:

     * ‘4’: 보통 세로획 → 가로획 → 대각선획 순서
     * ‘5’: 위 가로 → 세로 아래로 → 아래 가로
   * 간단히: “몇 번째 스트로크가 위쪽/아래쪽/왼쪽/오른쪽 영역에 있는지”를 구간으로 나눠서 기록.

---

## 3. 교차 / 루프 / 모양 기반 특징

### 3-1. 스트로크 교차(Intersection)

1. 각 스트로크를 선분들의 집합으로 보고,
2. 모든 선분 쌍에 대해:

   * 서로 다른 스트로크 간 교차 개수
   * 같은 스트로크 내 self-intersection 개수
3. 교차 수/위치로:

   * 4: 중간 교차점이 뚜렷이 존재하는 경우 많음.
   * 8: 위/아래 루프가 겹쳐 보이는 self-intersection 패턴.
   * 0: 교차는 적지만 “닫힌 루프”의 존재가 중요.

### 3-2. 루프(구멍) 개수

1. 모든 스트로크를 rasterize → 이진 이미지(선=1, 배경=0).
2. 배경(0) 영역에 대해 연결 성분 분석 → **내부 구멍 개수**를 세기.

   * 구멍 2개: 8
   * 구멍 1개:

     * 구멍 위치/비율로 0, 6, 9를 구분.
   * 구멍 0개:

     * 1, 2, 3, 4, 5, 7

---

## 4. 오프라인 이미지 기반 특징 (간단한 것만)

1. **가로/세로 비율 (width / height)**

   * 세로로 매우 길쭉: 1
   * 거의 정사각형: 0, 6, 8, 9
   * 가로로 넓은 편: 2, 3, 5, 7

2. **상·하 / 좌·우 투영**

   * 각 행/열마다 “픽셀 count”를 구해 1D 프로파일로 사용.
   * 예:

     * 위쪽에만 선이 많고 아래가 비어 있음 → 7
     * 위·아래 모두 차있고 가운데가 비는 패턴 → 0, 8

3. **무게중심 위치**

   * 전체 픽셀들의 평균 위치 (cx, cy):

     * 위쪽으로 치우친 9, 7
     * 중앙에 가까운 0, 8
     * 아래로 약간 치우친 2, 3, 5

---

## 5. 숫자별 간단 규칙 예시 (아이디어 수준)

아주 러프하게만 적어보면:

* **0**

  * 루프 수 = 1
  * 가로/세로 비율 ≈ 1 (정사각형)
  * 시작점·끝점이 거의 만나거나, 같은 스트로크 내 self-intersection이 적음.

* **1**

  * 스트로크 수 1 (또는 2)
  * 세로 길이 ≫ 가로 길이, 위→아래 방향 선이 지배적
  * 루프 = 0, 교차 거의 없음.

* **2**

  * 루프 = 0
  * 상단에 가로/곡선, 하단은 오른쪽으로 열려 있는 곡선
  * 상단에 픽셀이 많고, 아래쪽 오른쪽으로 치우친 무게중심.

* **3**

  * 좌우 비율에서 오른쪽으로 많이 치우친 곡선 두 개
  * 수직 축 투영에서 중간 부위가 비어 있지 않고, 오른쪽에 두 봉우리가 있는 형태.

* **4**

  * 스트로크 수 ≥ 2
  * 명확한 교차점 1개 이상 (가로/세로/대각이 만나는)
  * 세로획 + 가로획 + 대각획 패턴.

* **5**

  * 위쪽 가로 + 중앙 세로 + 아래 가로 패턴
  * 루프 = 0, 무게중심이 조금 아래쪽.

* **6**

  * 루프 = 1, 루프가 아래쪽에 위치
  * 스트로크 시작이 위쪽에서 아래로 내려와 루프를 형성.

* **7**

  * 스트로크 수 1이 많음
  * 윗부분 가로획 + 약간의 하강 (우하향)
  * 아래쪽 픽셀이 상대적으로 적음.

* **8**

  * 루프 = 2
  * 위·아래 두 루프의 높이가 비슷 (투영을 보면 상단·하단이 모두 두꺼움).

* **9**

  * 루프 = 1, 루프가 위쪽에 위치
  * 시작이 위/중간에서 루프를 만든 뒤 아래로 꼬리가 떨어지는 패턴.

---

## 6. 실전 구현 팁

1. **feature vector 설계**

   * 예시:

     ```text
     [strokeCount,
      widthHeightRatio,
      loopCount,
      intersectionCount,
      startX1, startY1, endX1, endY1,
      ... (주요 stroke의 방향, 길이),
      topDensity, bottomDensity, leftDensity, rightDensity,
      centerOfMassX, centerOfMassY]
     ```
   * 이런 걸 한 20~40차원 정도로 만들고,

2. **“규칙 + 근접 탐색” 혼합**

   * 1차로 **명확한 규칙** (루프 수, strokeCount, extremely tall → 1, etc.)
   * 애매한 것들은 간단한:

     * k-NN(저장해 둔 예시 feature들과 거리 비교)
     * 또는 “점수 기반” if-else로 해결
       → 여전히 **구조적 특징 기반**이지만, 약간의 유연성을 줄 수 있음.

---

정리하면,

* 온라인 필기의 강점을 살리려면
  **“스트로크 개수 + 시작/끝 위치 + 방향 + 교차 + 루프 + 가로/세로 비 + 투영”**
  정도를 한 세트로 묶어서 feature로 생각하면 좋습니다.
* 그 위에 숫자별 전형적인 패턴을 규칙화하고,
  애매한 부분은 간단한 k-NN이나 점수 방식으로 보완하면
  “완전 구조적이면서도 꽤 안정적인” 온라인 숫자 인식기를 만들 수 있어요.

원하시면 다음 단계로,

* 실제로 `StrokeData`에서 어떤 수식을 써서 feature를 뽑을지,
* 예를 들어 “루프 개수 계산 코드 스케치” 같은 걸 C++/WinRT 스타일로 같이 짜볼 수도 있습니다.
